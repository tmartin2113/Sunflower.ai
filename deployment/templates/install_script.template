#!/bin/bash
################################################################################
# Sunflower AI Professional System - Installation Script Template
# Version: ${VERSION}
# Build: ${BUILD_NUMBER}
# Platform: ${PLATFORM}
# Device ID: ${DEVICE_ID}
################################################################################

set -euo pipefail  # Exit on error, undefined variables, and pipe failures

################################################################################
# CONFIGURATION VARIABLES (populated during build)
################################################################################

readonly VERSION="${VERSION:-6.2.0}"
readonly BUILD_NUMBER="${BUILD_NUMBER:-001}"
readonly PLATFORM="${PLATFORM:-universal}"
readonly DEVICE_ID="${DEVICE_ID:-UNKNOWN}"
readonly PRODUCT_NAME="Sunflower AI Professional"
readonly INSTALL_DIR="${INSTALL_DIR:-/opt/sunflowerai}"
readonly DATA_DIR="${DATA_DIR:-${HOME}/.sunflowerai}"
readonly LOG_DIR="${LOG_DIR:-${DATA_DIR}/logs}"
readonly TEMP_DIR="${TEMP_DIR:-/tmp/sunflowerai_install}"
readonly MIN_RAM_GB="${MIN_RAM_GB:-4}"
readonly MIN_DISK_GB="${MIN_DISK_GB:-8}"
readonly MODELS_LIST="${MODELS_LIST:-llama3.2:7b,llama3.2:3b,llama3.2:1b,llama3.2:1b-q4_0}"

################################################################################
# COLOR CODES FOR OUTPUT
################################################################################

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly RESET='\033[0m'

################################################################################
# LOGGING AND PROGRESS TRACKING
################################################################################

readonly LOG_FILE="${LOG_DIR}/installation_$(date +%Y%m%d_%H%M%S).log"
readonly ERROR_LOG="${LOG_DIR}/installation_errors.log"
INSTALLATION_PROGRESS=0

# Initialize logging
init_logging() {
    mkdir -p "${LOG_DIR}"
    touch "${LOG_FILE}"
    touch "${ERROR_LOG}"
    
    exec 1> >(tee -a "${LOG_FILE}")
    exec 2> >(tee -a "${ERROR_LOG}" >&2)
    
    log_message "INFO" "Installation started at $(date)"
    log_message "INFO" "Version: ${VERSION}, Build: ${BUILD_NUMBER}"
    log_message "INFO" "Platform: ${PLATFORM}, Device: ${DEVICE_ID}"
}

# Log messages with timestamp and level
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[${timestamp}] [${level}] ${message}" >> "${LOG_FILE}"
    
    case "${level}" in
        ERROR)
            echo "[${timestamp}] [${level}] ${message}" >> "${ERROR_LOG}"
            echo -e "${RED}[${level}]${RESET} ${message}" >&2
            ;;
        WARNING)
            echo -e "${YELLOW}[${level}]${RESET} ${message}"
            ;;
        SUCCESS)
            echo -e "${GREEN}[${level}]${RESET} ${message}"
            ;;
        INFO)
            echo -e "${CYAN}[${level}]${RESET} ${message}"
            ;;
        *)
            echo "[${level}] ${message}"
            ;;
    esac
}

# Update progress indicator
update_progress() {
    INSTALLATION_PROGRESS=$1
    local status="$2"
    
    local filled=$((INSTALLATION_PROGRESS / 2))
    local empty=$((50 - filled))
    
    printf "\r${CYAN}Progress: [${GREEN}"
    printf "%${filled}s" | tr ' ' '█'
    printf "${WHITE}"
    printf "%${empty}s" | tr ' ' '░'
    printf "${CYAN}] ${INSTALLATION_PROGRESS}%% - ${status}${RESET}"
    
    if [[ ${INSTALLATION_PROGRESS} -eq 100 ]]; then
        echo ""
    fi
    
    log_message "PROGRESS" "${INSTALLATION_PROGRESS}% - ${status}"
}

################################################################################
# SECURITY FUNCTIONS
################################################################################

# FIX BUG-017: Validate and sanitize path components to prevent traversal
validate_path_component() {
    local component="$1"
    
    # Remove any leading/trailing whitespace
    component=$(echo "${component}" | xargs)
    
    # Check for empty component
    if [[ -z "${component}" ]]; then
        log_message "ERROR" "Empty path component detected"
        return 1
    fi
    
    # Check for path traversal attempts
    if [[ "${component}" == *".."* ]] || [[ "${component}" == *"/"* ]] || [[ "${component}" == *"\\"* ]]; then
        log_message "ERROR" "Path traversal attempt detected in: ${component}"
        return 1
    fi
    
    # Check for special characters that could be malicious
    if [[ "${component}" =~ [^\w\-\._] ]]; then
        log_message "WARNING" "Suspicious characters in path component: ${component}"
        # Don't fail, but log the warning
    fi
    
    # Check for absolute paths
    if [[ "${component}" == /* ]] || [[ "${component}" == ~* ]]; then
        log_message "ERROR" "Absolute path not allowed: ${component}"
        return 1
    fi
    
    # Return sanitized component (basename only)
    basename "${component}" 2>/dev/null || echo "${component}"
}

# FIX BUG-017: Secure file copy with validation
secure_copy() {
    local source="$1"
    local destination="$2"
    local copy_type="${3:-file}"  # file or directory
    
    # Validate source exists and is within expected bounds
    if [[ ! -e "${source}" ]]; then
        log_message "ERROR" "Source does not exist: ${source}"
        return 1
    fi
    
    # Get real paths to prevent symlink attacks
    local real_source=$(realpath "${source}" 2>/dev/null) || source="${source}"
    local real_dest_parent=$(realpath "$(dirname "${destination}")" 2>/dev/null) || real_dest_parent="$(dirname "${destination}")"
    
    # Ensure destination parent exists
    mkdir -p "${real_dest_parent}"
    
    # Verify destination is within INSTALL_DIR
    if [[ "${real_dest_parent}" != "${INSTALL_DIR}"* ]]; then
        log_message "ERROR" "Destination outside installation directory: ${destination}"
        return 1
    fi
    
    # Perform the copy
    if [[ "${copy_type}" == "directory" ]]; then
        cp -r "${real_source}" "${destination}" 2>/dev/null
    else
        cp "${real_source}" "${destination}" 2>/dev/null
    fi
    
    return $?
}

# Check for required privileges
check_privileges() {
    log_message "INFO" "Checking installation privileges..."
    
    case "${PLATFORM}" in
        windows)
            # Check for Administrator privileges on Windows
            net session >/dev/null 2>&1
            if [[ $? -ne 0 ]]; then
                log_message "ERROR" "Administrator privileges required on Windows"
                return 1
            fi
            ;;
        macos)
            # macOS doesn't require root for /Applications
            if [[ ! -w "/Applications" ]] && [[ ${EUID} -ne 0 ]]; then
                log_message "WARNING" "May need administrator privileges for /Applications"
            fi
            ;;
        linux)
            # Check for appropriate permissions
            if [[ ! -w "${INSTALL_DIR%/*}" ]] && [[ ${EUID} -ne 0 ]]; then
                log_message "WARNING" "May need sudo privileges for ${INSTALL_DIR}"
            fi
            ;;
    esac
    return 0
}

################################################################################
# SYSTEM VERIFICATION FUNCTIONS
################################################################################

# Detect operating system and architecture
detect_system() {
    log_message "INFO" "Detecting system configuration..."
    
    local os_type=""
    local arch_type=""
    
    case "$(uname -s)" in
        Darwin*)
            os_type="macos"
            arch_type=$(uname -m)
            ;;
        Linux*)
            os_type="linux"
            arch_type=$(uname -m)
            ;;
        CYGWIN*|MINGW*|MSYS*)
            os_type="windows"
            arch_type=$(wmic os get osarchitecture | grep -o '[0-9]*-bit')
            ;;
        *)
            log_message "ERROR" "Unsupported operating system: $(uname -s)"
            return 1
            ;;
    esac
    
    # Verify platform matches
    if [[ "${PLATFORM}" != "${os_type}" ]] && [[ "${PLATFORM}" != "universal" ]]; then
        log_message "ERROR" "Platform mismatch. Expected: ${PLATFORM}, Found: ${os_type}"
        return 1
    fi
    
    log_message "SUCCESS" "System detected: ${os_type} (${arch_type})"
    return 0
}

# Check hardware requirements
check_hardware() {
    log_message "INFO" "Checking hardware requirements..."
    
    # Check RAM
    local ram_kb=0
    case "${PLATFORM}" in
        macos)
            ram_kb=$(sysctl -n hw.memsize | awk '{print int($1/1024)}')
            ;;
        linux)
            ram_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
            ;;
        windows)
            ram_kb=$(wmic computersystem get TotalPhysicalMemory | grep -o '[0-9]*' | awk '{print int($1/1024)}')
            ;;
    esac
    
    local ram_gb=$((ram_kb / 1024 / 1024))
    log_message "INFO" "System RAM: ${ram_gb} GB"
    
    if [[ ${ram_gb} -lt ${MIN_RAM_GB} ]]; then
        log_message "ERROR" "Insufficient RAM. Required: ${MIN_RAM_GB}GB, Found: ${ram_gb}GB"
        return 1
    fi
    
    # Check disk space
    local available_space_gb=0
    case "${PLATFORM}" in
        macos|linux)
            available_space_gb=$(df -BG "${INSTALL_DIR%/*}" | awk 'NR==2 {print int($4)}')
            ;;
        windows)
            available_space_gb=$(wmic logicaldisk get size,freespace | grep -o '[0-9]*' | awk 'NR==2 {print int($1/1024/1024/1024)}')
            ;;
    esac
    
    log_message "INFO" "Available disk space: ${available_space_gb} GB"
    
    if [[ ${available_space_gb} -lt ${MIN_DISK_GB} ]]; then
        log_message "ERROR" "Insufficient disk space. Required: ${MIN_DISK_GB}GB, Available: ${available_space_gb}GB"
        return 1
    fi
    
    # Recommend model based on RAM
    local recommended_model=""
    if [[ ${ram_gb} -ge 16 ]]; then
        recommended_model="llama3.2:7b"
        log_message "INFO" "High-spec system detected. Recommending ${recommended_model}"
    elif [[ ${ram_gb} -ge 8 ]]; then
        recommended_model="llama3.2:3b"
        log_message "INFO" "Mid-range system detected. Recommending ${recommended_model}"
    elif [[ ${ram_gb} -ge 4 ]]; then
        recommended_model="llama3.2:1b"
        log_message "INFO" "Standard system detected. Recommending ${recommended_model}"
    else
        recommended_model="llama3.2:1b-q4_0"
        log_message "WARNING" "Low-spec system detected. Using quantized model: ${recommended_model}"
    fi
    
    echo "${recommended_model}" > "${LOG_DIR}/recommended_model.txt"
    
    log_message "SUCCESS" "Hardware requirements satisfied"
    return 0
}

# Check for existing installation
check_existing_installation() {
    log_message "INFO" "Checking for existing installation..."
    
    if [[ -d "${INSTALL_DIR}" ]]; then
        log_message "WARNING" "Existing installation found at ${INSTALL_DIR}"
        
        # Check version of existing installation
        local version_file="${INSTALL_DIR}/version_info.json"
        if [[ -f "${version_file}" ]]; then
            local existing_version=$(grep '"version"' "${version_file}" | cut -d'"' -f4)
            log_message "INFO" "Existing version: ${existing_version}"
            
            # Prompt for action
            echo -e "\n${YELLOW}An existing installation was found.${RESET}"
            echo "Options:"
            echo "  1) Upgrade existing installation"
            echo "  2) Backup and replace"
            echo "  3) Cancel installation"
            echo -n "Select option (1-3): "
            read -r option
            
            case "${option}" in
                1)
                    log_message "INFO" "User selected: Upgrade"
                    backup_existing_data
                    ;;
                2)
                    log_message "INFO" "User selected: Backup and replace"
                    backup_existing_data
                    rm -rf "${INSTALL_DIR}"
                    ;;
                3)
                    log_message "INFO" "User cancelled installation"
                    return 1
                    ;;
                *)
                    log_message "ERROR" "Invalid option selected"
                    return 1
                    ;;
            esac
        fi
    else
        log_message "INFO" "No existing installation found"
    fi
    
    return 0
}

################################################################################
# INSTALLATION FUNCTIONS
################################################################################

# Copy files from CD-ROM partition to installation directory
install_system_files() {
    log_message "INFO" "Installing system files..."
    update_progress 20 "Copying system files"
    
    # Get source directory (CD-ROM partition)
    local source_dir=""
    if [[ -n "${BASH_SOURCE[0]}" ]]; then
        source_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    else
        source_dir="$(pwd)"
    fi
    
    # Validate source directory
    source_dir=$(realpath "${source_dir}" 2>/dev/null) || source_dir="${source_dir}"
    
    # Create installation directory structure
    local directories=(
        "${INSTALL_DIR}"
        "${INSTALL_DIR}/models"
        "${INSTALL_DIR}/modelfiles"
        "${INSTALL_DIR}/interface"
        "${INSTALL_DIR}/documentation"
        "${INSTALL_DIR}/ollama"
        "${INSTALL_DIR}/logs"
        "${INSTALL_DIR}/temp"
        "${INSTALL_DIR}/assets"
        "${INSTALL_DIR}/launchers"
    )
    
    for dir in "${directories[@]}"; do
        mkdir -p "${dir}"
        if [[ $? -ne 0 ]]; then
            log_message "ERROR" "Failed to create directory: ${dir}"
            return 1
        fi
    done
    
    update_progress 30 "Created directory structure"
    
    # FIX BUG-017: Copy core files with path validation
    local components=(
        "launchers:executable"
        "models:data"
        "modelfiles:config"
        "interface:code"
        "documentation:docs"
        "ollama:executable"
        "assets:resources"
    )
    
    local current_progress=30
    local progress_increment=$((50 / ${#components[@]}))
    
    for component in "${components[@]}"; do
        IFS=':' read -r name type <<< "${component}"
        
        # FIX BUG-017: Validate component name to prevent path traversal
        name=$(validate_path_component "${name}")
        if [[ $? -ne 0 ]] || [[ -z "${name}" ]]; then
            log_message "ERROR" "Invalid component name: ${name}"
            continue
        fi
        
        log_message "INFO" "Installing ${name}..."
        
        # Check if source exists
        if [[ -d "${source_dir}/${name}" ]]; then
            # FIX BUG-017: Use secure copy function instead of direct cp
            local src_path="${source_dir}/${name}"
            local dest_path="${INSTALL_DIR}/${name}"
            
            # Validate paths are within bounds
            if [[ "${dest_path}" != "${INSTALL_DIR}/"* ]]; then
                log_message "ERROR" "Invalid destination path for ${name}"
                continue
            fi
            
            # Copy files securely
            find "${src_path}" -type f -print0 2>/dev/null | while IFS= read -r -d '' file; do
                local relative_path="${file#${src_path}/}"
                local dest_file="${dest_path}/${relative_path}"
                local dest_dir=$(dirname "${dest_file}")
                
                # Create destination directory if needed
                mkdir -p "${dest_dir}"
                
                # Copy file with validation
                if secure_copy "${file}" "${dest_file}" "file"; then
                    # Set permissions based on type
                    case "${type}" in
                        executable)
                            chmod +x "${dest_file}" 2>/dev/null
                            ;;
                        config)
                            chmod 644 "${dest_file}" 2>/dev/null
                            ;;
                        *)
                            chmod 644 "${dest_file}" 2>/dev/null
                            ;;
                    esac
                else
                    log_message "WARNING" "Failed to copy file: ${relative_path}"
                fi
            done
            
            current_progress=$((current_progress + progress_increment))
            update_progress ${current_progress} "Installed ${name}"
        else
            log_message "WARNING" "Component not found: ${name}"
        fi
    done
    
    # Copy version info with validation
    if [[ -f "${source_dir}/version_info.json" ]]; then
        secure_copy "${source_dir}/version_info.json" "${INSTALL_DIR}/version_info.json" "file"
    fi
    
    if [[ -f "${source_dir}/device_config.json" ]]; then
        secure_copy "${source_dir}/device_config.json" "${INSTALL_DIR}/device_config.json" "file"
    fi
    
    update_progress 80 "System files installed"
    log_message "SUCCESS" "System files installation completed"
    return 0
}

# Configure the installation for first run
configure_installation() {
    log_message "INFO" "Configuring installation..."
    update_progress 85 "Configuring system"
    
    # Create configuration file
    local config_file="${INSTALL_DIR}/config.json"
    cat > "${config_file}" << EOF
{
    "version": "${VERSION}",
    "build_number": "${BUILD_NUMBER}",
    "installation_date": "$(date -Iseconds)",
    "device_id": "${DEVICE_ID}",
    "platform": "${PLATFORM}",
    "install_directory": "${INSTALL_DIR}",
    "first_run": true,
    "model_settings": {
        "default_model": "$(cat ${LOG_DIR}/recommended_model.txt 2>/dev/null || echo 'llama3.2:1b')",
        "available_models": [${MODELS_LIST}]
    },
    "paths": {
        "models": "${INSTALL_DIR}/models",
        "modelfiles": "${INSTALL_DIR}/modelfiles",
        "logs": "${LOG_DIR}",
        "data": "${DATA_DIR}",
        "temp": "${TEMP_DIR}"
    },
    "security": {
        "enforce_parent_controls": true,
        "content_filtering": "strict",
        "session_logging": true,
        "age_verification": true
    }
}
EOF
    
    # Set appropriate permissions
    chmod 600 "${config_file}"
    
    # Platform-specific configuration
    case "${PLATFORM}" in
        macos)
            configure_macos
            ;;
        windows)
            configure_windows
            ;;
        linux)
            configure_linux
            ;;
    esac
    
    update_progress 90 "Configuration completed"
    log_message "SUCCESS" "Installation configured successfully"
    return 0
}

# macOS-specific configuration
configure_macos() {
    log_message "INFO" "Applying macOS-specific configuration..."
    
    # Create app bundle symlink
    if [[ -d "/Applications" ]]; then
        ln -sf "${INSTALL_DIR}" "/Applications/${PRODUCT_NAME}.app"
    fi
    
    # Create LaunchAgent for background service
    local plist_file="${HOME}/Library/LaunchAgents/com.sunflowerai.service.plist"
    mkdir -p "${HOME}/Library/LaunchAgents"
    
    cat > "${plist_file}" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.sunflowerai.service</string>
    <key>ProgramArguments</key>
    <array>
        <string>${INSTALL_DIR}/sunflower_service</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <false/>
</dict>
</plist>
EOF
    
    # Load the service
    launchctl load "${plist_file}" 2>/dev/null
    
    # Create desktop alias
    local desktop="${HOME}/Desktop"
    if [[ -d "${desktop}" ]]; then
        ln -sf "${INSTALL_DIR}" "${desktop}/${PRODUCT_NAME}.app"
    fi
}

# Linux-specific configuration
configure_linux() {
    log_message "INFO" "Applying Linux-specific configuration..."
    
    # Create desktop entry
    local desktop_file="${HOME}/.local/share/applications/sunflowerai.desktop"
    mkdir -p "${HOME}/.local/share/applications"
    
    cat > "${desktop_file}" << EOF
[Desktop Entry]
Version=1.0
Type=Application
Name=${PRODUCT_NAME}
Comment=Family-focused K-12 STEM Education System
Exec=${INSTALL_DIR}/launcher
Icon=${INSTALL_DIR}/assets/sunflower.png
Terminal=false
Categories=Education;Science;
Keywords=education;stem;ai;learning;
EOF
    
    # Create systemd service (optional)
    local service_file="${HOME}/.config/systemd/user/sunflowerai.service"
    mkdir -p "${HOME}/.config/systemd/user"
    
    cat > "${service_file}" << EOF
[Unit]
Description=Sunflower AI Background Service
After=graphical-session.target

[Service]
Type=simple
ExecStart=${INSTALL_DIR}/sunflower_service
Restart=on-failure
RestartSec=10

[Install]
WantedBy=default.target
EOF
    
    # Update desktop database
    update-desktop-database "${HOME}/.local/share/applications" 2>/dev/null
}

# Windows-specific configuration
configure_windows() {
    log_message "INFO" "Applying Windows-specific configuration..."
    
    # Create Start Menu shortcut
    local start_menu="${APPDATA}/Microsoft/Windows/Start Menu/Programs/${PRODUCT_NAME}"
    mkdir -p "${start_menu}"
    
    # Use PowerShell to create shortcut
    powershell -Command "
        \$WshShell = New-Object -comObject WScript.Shell
        \$Shortcut = \$WshShell.CreateShortcut('${start_menu}\\${PRODUCT_NAME}.lnk')
        \$Shortcut.TargetPath = '${INSTALL_DIR}\\launcher.exe'
        \$Shortcut.WorkingDirectory = '${INSTALL_DIR}'
        \$Shortcut.IconLocation = '${INSTALL_DIR}\\assets\\sunflower.ico'
        \$Shortcut.Save()
    "
    
    # Create Desktop shortcut
    powershell -Command "
        \$WshShell = New-Object -comObject WScript.Shell
        \$Desktop = [System.Environment]::GetFolderPath('Desktop')
        \$Shortcut = \$WshShell.CreateShortcut(\"\$Desktop\\${PRODUCT_NAME}.lnk\")
        \$Shortcut.TargetPath = '${INSTALL_DIR}\\launcher.exe'
        \$Shortcut.WorkingDirectory = '${INSTALL_DIR}'
        \$Shortcut.IconLocation = '${INSTALL_DIR}\\assets\\sunflower.ico'
        \$Shortcut.Save()
    "
    
    # Add to PATH (optional)
    # setx PATH "%PATH%;${INSTALL_DIR}" /M
    
    # Configure Windows Defender exclusion
    powershell -Command "Add-MpPreference -ExclusionPath '${INSTALL_DIR}'" 2>/dev/null
}

################################################################################
# POST-INSTALLATION FUNCTIONS
################################################################################

# Verify the installation
verify_installation() {
    log_message "INFO" "Verifying installation..."
    update_progress 95 "Verifying installation"
    
    local verification_passed=true
    
    # Check critical files
    local critical_files=(
        "${INSTALL_DIR}/version_info.json"
        "${INSTALL_DIR}/config.json"
        "${INSTALL_DIR}/modelfiles/Sunflower_AI_Kids.modelfile"
        "${INSTALL_DIR}/modelfiles/Sunflower_AI_Educator.modelfile"
    )
    
    for file in "${critical_files[@]}"; do
        if [[ ! -f "${file}" ]]; then
            log_message "ERROR" "Critical file missing: ${file}"
            verification_passed=false
        fi
    done
    
    # Check directories
    local required_dirs=(
        "${INSTALL_DIR}/models"
        "${INSTALL_DIR}/interface"
        "${INSTALL_DIR}/documentation"
    )
    
    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "${dir}" ]]; then
            log_message "ERROR" "Required directory missing: ${dir}"
            verification_passed=false
        fi
    done
    
    # Verify permissions
    case "${PLATFORM}" in
        macos|linux)
            if [[ ! -x "${INSTALL_DIR}/launcher" ]]; then
                log_message "WARNING" "Launcher not executable, fixing..."
                chmod +x "${INSTALL_DIR}/launcher" 2>/dev/null
            fi
            ;;
        windows)
            if [[ ! -f "${INSTALL_DIR}/launcher.exe" ]]; then
                log_message "ERROR" "Windows launcher missing"
                verification_passed=false
            fi
            ;;
    esac
    
    if [[ "${verification_passed}" == true ]]; then
        log_message "SUCCESS" "Installation verification passed"
        return 0
    else
        log_message "ERROR" "Installation verification failed"
        return 1
    fi
}

# Display completion message
show_completion_message() {
    echo ""
    echo -e "${GREEN}╔════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${GREEN}║                                                            ║${RESET}"
    echo -e "${GREEN}║     INSTALLATION COMPLETE!                                ║${RESET}"
    echo -e "${GREEN}║                                                            ║${RESET}"
    echo -e "${GREEN}╚════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
    echo -e "${WHITE}${PRODUCT_NAME} has been successfully installed!${RESET}"
    echo ""
    echo -e "${CYAN}Installation Directory:${RESET} ${INSTALL_DIR}"
    echo -e "${CYAN}Data Directory:${RESET} ${DATA_DIR}"
    echo -e "${CYAN}Log Directory:${RESET} ${LOG_DIR}"
    echo ""
    echo -e "${YELLOW}Next Steps:${RESET}"
    
    case "${PLATFORM}" in
        macos)
            echo "  1. Open Applications folder"
            echo "  2. Double-click ${PRODUCT_NAME}"
            echo "  3. Follow the family setup wizard"
            ;;
        windows)
            echo "  1. Find ${PRODUCT_NAME} on your Desktop"
            echo "  2. Double-click to launch"
            echo "  3. Follow the family setup wizard"
            ;;
        linux)
            echo "  1. Run: ${INSTALL_DIR}/launcher"
            echo "  2. Or find in Applications menu"
            echo "  3. Follow the family setup wizard"
            ;;
    esac
    
    echo ""
    echo -e "${CYAN}Documentation:${RESET}"
    echo "  • User Guide: ${INSTALL_DIR}/documentation/user_guide.pdf"
    echo "  • Quick Start: ${INSTALL_DIR}/documentation/quick_start.pdf"
    echo ""
    echo -e "${GREEN}Thank you for choosing Sunflower AI!${RESET}"
    echo ""
}

# Backup existing data
backup_existing_data() {
    log_message "INFO" "Backing up existing data..."
    
    local backup_dir="${HOME}/.sunflowerai/backups/backup_$(date +%Y%m%d_%H%M%S)"
    mkdir -p "${backup_dir}"
    
    # Backup user data
    if [[ -d "${HOME}/.sunflowerai/data" ]]; then
        cp -r "${HOME}/.sunflowerai/data" "${backup_dir}/"
        log_message "SUCCESS" "User data backed up to ${backup_dir}"
    fi
    
    # Backup configuration
    if [[ -f "${INSTALL_DIR}/config.json" ]]; then
        cp "${INSTALL_DIR}/config.json" "${backup_dir}/"
    fi
    
    return 0
}

# Handle installation errors
handle_error() {
    local error_code=$1
    local error_message="$2"
    
    log_message "ERROR" "${error_message}"
    
    echo ""
    echo -e "${RED}╔════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${RED}║                   INSTALLATION FAILED                      ║${RESET}"
    echo -e "${RED}╚════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
    echo -e "${RED}Error Code: ${error_code}${RESET}"
    echo -e "${RED}Error: ${error_message}${RESET}"
    echo ""
    echo "Installation log: ${LOG_FILE}"
    echo "Error log: ${ERROR_LOG}"
    echo ""
    echo "For support, please consult the troubleshooting guide"
    echo "or visit: https://sunflowerai.education/support"
    echo ""
    
    # Cleanup partial installation
    if [[ "${INSTALLATION_PROGRESS}" -gt 0 ]] && [[ "${INSTALLATION_PROGRESS}" -lt 100 ]]; then
        echo -n "Remove partial installation? (y/n): "
        read -r response
        if [[ "${response}" == "y" ]]; then
            rm -rf "${INSTALL_DIR}"
            log_message "INFO" "Partial installation removed"
        fi
    fi
    
    exit ${error_code}
}

################################################################################
# MAIN INSTALLATION FLOW
################################################################################

main() {
    # Initialize
    init_logging
    
    echo ""
    echo -e "${MAGENTA}╔════════════════════════════════════════════════════════════╗${RESET}"
    echo -e "${MAGENTA}║                                                            ║${RESET}"
    echo -e "${MAGENTA}║     SUNFLOWER AI PROFESSIONAL SYSTEM                      ║${RESET}"
    echo -e "${MAGENTA}║     Family-Focused K-12 STEM Education                    ║${RESET}"
    echo -e "${MAGENTA}║                                                            ║${RESET}"
    echo -e "${MAGENTA}║     Version ${VERSION}                                        ║${RESET}"
    echo -e "${MAGENTA}║                                                            ║${RESET}"
    echo -e "${MAGENTA}╚════════════════════════════════════════════════════════════╝${RESET}"
    echo ""
    
    update_progress 0 "Starting installation"
    
    # Pre-installation checks
    check_privileges || handle_error 1 "Insufficient privileges"
    
    update_progress 5 "Detecting system"
    detect_system || handle_error 2 "System detection failed"
    
    update_progress 10 "Checking hardware"
    check_hardware || handle_error 3 "Hardware requirements not met"
    
    update_progress 15 "Checking for existing installation"
    check_existing_installation || handle_error 4 "Existing installation conflict"
    
    # Main installation
    install_system_files || handle_error 5 "Failed to install system files"
    configure_installation || handle_error 6 "Configuration failed"
    verify_installation || handle_error 7 "Verification failed"
    
    # Complete
    update_progress 100 "Installation complete"
    show_completion_message
    
    # Offer to launch
    echo -n "Launch ${PRODUCT_NAME} now? (y/n): "
    read -r response
    if [[ "${response}" == "y" ]]; then
        case "${PLATFORM}" in
            macos)
                open "${INSTALL_DIR}"
                ;;
            windows)
                start "" "${INSTALL_DIR}/launcher.exe"
                ;;
            linux)
                "${INSTALL_DIR}/launcher" &
                ;;
        esac
    fi
    
    exit 0
}

# Run main function
main "$@"
